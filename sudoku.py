#!/usr/bin/env python3
#Заполнение массива
#TODO: Строку нужно будет получать иначе - из файла, командной строки или интерактивно, туда же — проверу ввода. (СТРОГО ЖЕЛАТЕЛЬНО — интерактивно)
#TODO: Добавить возможность ршать головоломки произвольного размера с произвольным набором символов.

def output_puzzle(): #Вывод таблицы с головоломкой
	print('╔' + '═' * x + ('╤' + '═' * x) * (y - 1) + '╗')
	for i in range(X):
		print('║', end = '')
		for j in range(X):
			if arr[i][j] == '0':
				print(' ', end = '')
			else:
				print(arr[i][j], end = '')
			if (((j + 1) % x) == 0) and (j != (X - 1)):
				print('│', end = '')
		print('║')
		if ((i + 1) % y) == 0 and (i != (X - 1)):
			print('╟' + '─' * x + ('┼' + '─' * x) * (y - 1) + '╢')
	print('╚' + '═' * x + ('╧' + '═' * x) * (y - 1) + '╝')


def show_possibles(): #Вывод возможных значений (для отладки)
	for i in range(X):
		for j in range(X):
			print(' ' * j, end='')
			print(possibles[i][j], end = '')
			print('\t\t\t\t\t//'+str(len(possibles[i][j])))

def set_num(x_ins, y_ins, num_ins, rule_ins = ''): #Установка значения в поле
	arr[x_ins][y_ins] = num_ins
	possibles[x_ins][y_ins] = set()
	for i in range(X): possibles[i][y_ins].discard(num_ins)
	for i in range(X): possibles[x_ins][i].discard(num_ins)
	for i in range(((x_ins // y) * y), ((x_ins // y + 1) * y)):
		for j in range(((y_ins // x) * x), ((y_ins // x + 1) * x)):
			possibles[i][j].discard(num_ins)
#СНЯТЬ КОММЕНТАРИИ СО СЛЕДУЮЩИХ ДВУХ СТРОК ДЛЯ ВЫВОДА ЛОГА
#	if rule_ins != '':
#		print('Set ' + str(num_ins) + ' in [' + str(x_ins + 1) + '][' + str(y_ins + 1) + '] by rule ' + rule_ins)

#x, y, chars = 2, 2, list('1234')
#line = '0001 1000 0003 2000'
#line = '1000 0020 0300 0004'
#line = '3020 0000 0000 0102'

#x, y, chars = 3, 2, list('123456')
#line = '500000 002006 000042 120000 300500 000003'
#line = '000010 050604 006000 000400 405020 030000'
#line = '002065 000200 200000 000006 001000 360400'
#line = '201000 030600 000500 004000 002040 000302'

#x, y, chars = 3, 3, list('123456789')
#line = '000109000 085304670 096000210 000902000 700000003 000803000 048000160 073408590 000706000'
#line = '409730102 020009600 010000390 000000021 000453000 680000000 051000030 006300010 904026805'
#˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅˅
#line = '050047001 000000708 804601050 103700000 000405000 000002406 020503904 405000000 900260010'
# Более сложная головоломка. Решение:
#359847261 261359748 874621359 143796825 692485173 587132496 726513984 415978632 938264517
#╔═══╤═══╤═══╗
#║359│847│261║
#║261│359│748║
#║874│621│359║
#╟───┼───┼───╢
#║143│796│825║
#║692│485│173║
#║587│132│496║
#╟───┼───┼───╢
#║726│513│984║
#║415│978│632║
#║938│264│517║
#╚═══╧═══╧═══╝
#˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄˄

#x, y, chars = 4, 3, list('123456789abc')
#line = '2b80403050c0 007080009000 0006b0000030 902000a01000 014000800600 700095100200 00b0046a0008 003001000970 00050c000402 03000007a000 000c00050300 08010b030c27'
#line = '5a7b00016090 010420000057 00000000c0b0 000000607005 0500030a2600 002070090804 80b060070900 001a90800020 40060c000000 0b0100000000 940000025010 070580004362'

#x, y, chars = 4, 4, list('123456789abcdefg')
#line = '0b00c60700500020 c056000000da0300 100a0df006048070 0d700ae000009100 503000000010b008 0a0g000070bc0e00 d00f1002400009gc 6020eg0bdf001000 000e006g108d0b07 438000056007c00d 00g0a30d0000f080 b00c0f000000060a 00a500000dg00cb0 0g07d0900b203001 00c031000000g205 01000e0090c30060'
#line = 'b5030c08d2000409 000900b0a0e00030 60000510c004020b 008g009050b00000 a0060300080f000e 20b01f007000000a 30008000009e00d2 087d400031006005 g00700e9000d8bf0 1c005d0000030004 8000000600170c0d 5000203000f07006 000009040g00bd00 70c0b0010350000f 010007030d009000 f09000gd40702018'

x, y, chars = 5, 4, list('123456789abcdefghijk')
line = '006ce00b0400j0070f05 480000500f0c0k0dbj20 015j00c309f0db20e000 0k0g0d6108074000a009 0005009d0i0gc00e2068 0070060043ik010050fg k0j00f0e0080a0000004 fd00000jbh600070c000 b000jh0050k000000406 0008040c000h0700i90b 704h00d01000g080j000 i0a000000j0400e10007 000108000ceji00000ad e000000g060020k00301 3g0i00a0914d00f00600 a50b700ke0901300f000 900a000h80b0fg504070 000k02bf0d30h8006c90 0h3d104070c00j0000ba 50e0g006002070083i00'


X = x * y
arr = []
for i in line.split():
	arr.append(list(i))

#Базовая проверка головоломки

if len(arr) != X:
	exit('Неправильное количество строк! Прерывание.')

for i in range(X):
	if len(arr[i]) != X:
		exit('В строке ' + str(i + 1) + ' неправильное количество столбцов! Прерывание.')

for i in range(X):
	for j in range(X):
		if arr[i][j] not in (chars + list('0')):
			exit('В ячейке [' + str(i + 1) + '][' + str(j + 1) + '] обнаружено недопустимое значение: ' + str(arr[i][j]) + '. Прерывание.')

print('Головоломка:')
output_puzzle()
#ПАУЗА ПЕРЕД ВЫВОДОМ ЛОГА
#input('Enter для продолжения')

#Первоначальное заполнение массива возможных значений
possibles=[[set(chars) for i in range(X)] for j in range(X)]
for i in range(X):
	for j in range(X):
		if arr[i][j] != '0':
			set_num(x_ins = i, y_ins = j, num_ins = arr[i][j])
#print('===================================')

#show_possibles()


#TODO: продумать превращение в одну или несколько функций, вызываемых из более фундаментального цикла.
for z in range(30): #TODO: Я полагаю, что for здесь неуместен. Здесь должен быть цикл, оценивающий прогресс.
	for i in range(X):
		for j in range(X):
			if len(possibles[i][j]) == 1: #Проверка, что в ячейку можно поставить только одно значение, при положителдьном результате — поставить его.
				set_num(x_ins = i, y_ins = j, num_ins = possibles[i][j].pop(), rule_ins = 'only one num possible in cell')
			for c in chars:
				if c in possibles[i][j]: #Обнаружение единственного возможного места для цифры в строке
					b = False
					for l in range(X):
						if l != j:
							b = b or possibles[i][l].issuperset(c)
					if not b: set_num(x_ins = i, y_ins = j, num_ins = c, rule_ins = 'only one place in string')
				if c in possibles[i][j]: #Обнаружение единственного возможного места для цифры в столбце
					b = False
					for l in range(X):
						if l != i:
							b = b or possibles[l][j].issuperset(c)
					if not b:
						set_num(x_ins = i, y_ins = j, num_ins = c, rule_ins = 'only one place in column')
				if c in possibles[i][j]: #Обнаружение единственного возможного места для цифры в зоне x * y
					b = False
					for l in range(((i // y) * y), ((i // y + 1) * y)):
						for m in range(((j // x) * x), ((j // x + 1) * x)):
							if l != i or j != m:
								b = b or possibles[l][m].issuperset(c)
					if not b:
						set_num(x_ins = i, y_ins = j, num_ins = c, rule_ins = 'only one place in area')
#	print()
#	print('=====================================')

#show_possibles()

#input('Enter для результата')

#TODO: добавить исключение возможного значения без собственно его простановки (если ясно, что в некоторых клетках число стоять не может в любом случае)
#TODO: добавить эвристическое ветвление в случае, если обычными тактиками головоломка не решается.
#	При возвращении от эвристики следует учесть, что возможны три варианта:
#	1. головоломка решена (йух-ху, мы выиграли, возвращаться не надо),
#	2. В головоломке появились явные ошиби (не имеет валидных решений, следовательно необходимо исключить изначальный выбор),
#	3. Головоломка не решена, но и не имеет видимых ошибок (следует запомнить расклад и вернуться к изначальной схеме не изменяя её;
#	если ни одно из стартовых допущений не приведёт к решению или ошибкам, то можно будет выбрать одну из этих веток (желательно наиболее заполненную)
#	для повтора ветвления). Следует так же иметь в виду, что головолома может оазаться В ПРИНЦИПЕ нерешаемой, хотя и будет проходить обычные проверки.

print('Решение:')
output_puzzle()
#show_possibles()
